## 06 数据结构基础


推荐：

* UVA-422 	栈经典习题
* UVA-12677 双向链表好题
* UVA-122 	蛮好的一个题，可以用建树来做，也可以用字符串来做。
* UVA-548 	经典二叉树习题
* UVA-1103 	当年WF的签到题，观察力+DFS，很有意思的一道题。
* UVA-816 	BFS套路题，有一些细节处理，对于新人比较锻炼代码能力。
* UVA-1572  DFS找环的经典题，考察基本算法和构图能力。
* UVA-1599  经典的两次BFS题目

不推荐：

* UVA-10562 输入数据说明错误，表示不明，故意挖坑。

---

### UVA-514 Rails

题意： 判断是否是出栈序列。

思路： 

1. 出栈序列中，比$a_i$小的后面数必然是降序的。所以枚举一下就可以了。 $O(n^3)$ [code](./uva514.cpp)
2. 模拟栈操作。序列中的a_i,如果它是已出的最大的数，那么把比它小还没有入栈的数入栈；否则如果它等于栈顶，出栈；否则不是出栈序列。 $(O(n))$ [code](./uva514-1.cpp)


### UVA-442 Matrix Chain Multiplication

题意：计算矩阵乘法的计算次数

思路：栈模拟，由于输入表达式都是合法的，所以遇到右括号就弹栈两次，计算代价，再压栈新矩阵的行列即可。 [code](./uva442.cpp)

### UVA-11988 Broken Keyboard

题意：一个输入字符串，`[`表示按`home`键，从行头开始输入，,`]`表示按`end`键，从行尾开始输入，求输出字符串。

思路： 链表。[code](./uva11988.cpp)

### UVA-12657 Boxes in a Line

题意: 一排n个数，四种指令，`1 x y` 将x放在y左边;`2 x y` 将x放在y右边; `3 x y` 交换x,y; `4` 逆序。m次指令后，奇数位的累加和。

思路：手写一个双向链表，前面3种操作对应操作每个节点的prev和next即可，操作4只要把方向变量取反即可。注意`3 x y`中x和y相邻的特殊情况。 [code](./uva12657.cpp)

### UVA-679 Dropping Balls

题意： 一个满二叉树，编号从$1$到$2^D - 1$。非叶子节点有一个开关，初始为开，每过一次球，状态翻转。球每次都从根开始下落，问第I个球落在哪个叶子节点上。保证I不会超过叶子节点数量。

思路： 找规律，把D=4的情况列出来，发现结果等于 1 << (D-1) | (I-1)的2进制逆序。 [code](./uva679.cpp)


### UVA-122 Trees on the level

题意： 给一个二叉树的节点编号，以及从根到这个节点的路径，问树按层次遍历的结果。不构成树，输出"not complete"。

思路：看上去需要重构这个二叉树，然后遍历，其实不用。
直接判断是否满足以下条件即可。

1. 根节点是否唯一。
2. 节点路径是否唯一。
3. 节点路径的前缀(前n-1个)路径节点有且仅有一个。

用multimap存<路径，编号>,然后枚举即可。注意自定义比较函数。

看题目的comment说标程有问题，没有考虑多个根不合法的情况。

[code](./uva122.cpp)


### UVA-548 Tree

题意：给一个二叉树的中序和后序遍历，求这个树从根到哪个叶子节点的路径点权和最小，如果存在多个满足条件的叶子，输出点权最小的叶子。

思路：二叉树的中序与后序可以唯一确定一个二叉树，用分治重构二叉树即可。
可以在重构的过程中维护节点的leaf，sum，分别表示从这个点为根的最短路径的叶子和路径权值。当然，也可以重构之后写个dfs来找。我用的是前面的方法。[code](./uva548.cpp)

### UVA-839 Not so Mobile

题意: 一个树状天平，问是否平衡？

思路：递归即可。 [code](./uva839.cpp)

### UVA-699 The Falling Leaves

题意：一个二叉树，每个节点有个x坐标，左孩子在其x-1位置，右孩子在其x+1位置，求所有坐标上节点的累加和。

思路：递归，把对应位置上的节点加到数组上即可。[code](./uva699.cpp)

### UVA-297 Quadtrees 

题意： 一个四分树表示$32 \times 32$的二值图，`f`表示当前层全黑，`e`表示当前层全白，`p`表示当前层杂色。给两个四分树的前序遍历，求合并以后，图像中黑点的数量。

思路：递归把二值图画出来，由于只有合并操作，所以在同一幅上面画两次就可以了，用了位压缩。[code](./uva297.cpp)

### UVA-572 Oil Deposits 

题意：`@`表示油库，8个方向相连，相连的属于同一个油库。问有几个不同的油库？

思路：dfs求联通分量。 [code](./uva572.cpp)

### UVA-1103 Ancient Messages

题意：给一个二进制表示的二值图像，识别其中的象形文字。不同象形文字中间的洞数量不一样。

思路：

1. 把图像扩两圈，0圈为背景色`2`，1圈为`0`,2圈开始为图像；
2. 先把外面的`0`染成背景色`2`；
3. 枚举所有点，如果是`1`,做dfs，如果发现`0`,洞数量+1,把其连通的`0`全部染成`2`。

[code](./uva1103.cpp)

### UVA-816 Abbott's Revenge

题意： 最多$9 \times 9$个网状节点，节点按进入的方向能去向不同的相邻的节点。问从起点到终点的最短路径。

思路：

1. 处理地图，把每个节点的四个方向设置允许的去向(根据进入方向`NESW`和`FLR`转换过来)。
2. 标准BFS，注意记录路径。这里最好用手写的队列，这样只需要记录前继节点即可；如果使用`queue`容器，需要在节点里记录到达路径。
3. 输出路径。由于记录的是前继节点，用递归或者栈来打印路径。 

[code](./uva816.cpp)

### UVA-10129 Play on Words

题意: 若干单词，问是否能组成一条接龙(前面单词的最后一个字符是后面单词的第一个字符)链。

思路: 判断一个有向图是否存在欧拉路。欧拉路判定：所有点入度和出度不超过1，为1的入度和出度点最多有1个。另外，需要判弱连通性，直接dfs或者并查集都可以。

[code](./uva10129.cpp)


### UVA-10562 Undraw the Trees

题意： 一个树的字符图，求输出树对应的字符串。

思路：递归套路题，主要是题目坑。 

1. 可能树图为空，直接给一个`#`的输入结束
2. 横线长度比下面子树节点的长度长，而子树节点最后是个串结束符。 


### UVA-1572 Self-Assembly 

题意： n种分子，每个分子上有四个接口，接口用两个字符表示，大写字母和加减号（00无视）。
接口如果同字符的加减，可以连接。问是否可以组成无限长的链接？

思路： 明显是一个找环的题。算法明确了，后面就是建图了。

一开始思路有点乱，以为是无向图，发现不对，比如分子1有1个A+，分子2有1个A-，这两个只能连接一次，不能再连接了。改成有向图，把一个分子构造成最多四个点， 每个点一个入口，其他为出口，结果超时了[tle](./uva1572_tle.cpp)。稍微有点疑惑，因为题目说的分子数最多为4万，点数不会超过16万，不应该超时才是，估计是堆了很多组样例吧。再仔细想想，构图使用接口作为点，则点数不会超过52个，然后就过了。[ac](./uva1572.cpp)

dfs 有向图找环算法： 标记访问状态为未访问，正在访问，结束访问三种。如果一个节点处于正在访问状态，又将被重复访问，则必然在dfs生成树上存在回边，存在环。


### UVA-1599 Ideal Path

题意：
n点无向图，边权为1，边上还有颜色，求1到n的最短路的颜色序列的最小字典序。

思路：

先从n开始，bfs，染色，得到最短路生成树，并标明层次；
再从1开始，把最短路生成树按层次遍历，每一层取个最小颜色。

[code](./uva1599.cpp)

书上说有一种只做一次的搞法，想了很久，不知道怎么搞。