## 07 暴力求解


推荐：

* UVA-725	这个更像是个STL的题
* UVA-11059	这个想$O(n)$的算法，还是挺好的题。
* UVA-129	很常见的暴力枚举+递归的题
* UVA-140	枚举排列
* UVA-1354	枚举二叉树（必做）
* UVA-1601  构图优化BFS，双向BFS
* UVA-11212 IDA*
* UVA-1343  IDA*
* UVA-1374  IDA*
* UVA-1602  打表，生成程序有点意思。
* UVA-818	题意有点费解，读懂题以后就是一个子集枚举+dfs的题。


不推荐：

* UVA-208 坑，输出尤其坑

-----

### UVA-725 Division

题意：

给一个N，找一个数码$0 \sim 9$的排列，使得 
$$
\frac{\;\overline{abcde}\;}{\;\overline{fghij}\;} = N
$$ 

思路：

$10! = 3628800$，直接枚举所有排列，计算N，对于查询，直接输出。 [code](./uva725.cpp)

### UVA-11059 Maximum Product

题意：

一个整数序列里，找出最大乘积的子段。

思路：

序列最大才18，所以可以用纯暴力$O(n^3)$ 或者 稍微优化一点的暴力 O(n^2)，都挺好写的。

其实这题可以用$O(n)$的算法解决。注意都是整数，所以如果都是非0的，乘积的绝对值是不会变小的。

	1. 如果存在某个元素是0，那么只需要计算之前和之后的，取大的即可。
	2. 对于一个不含0的序列区间[L,R]，如果负数的个数是偶数，那么结果是全部乘起来。
	3. 否则，找数列里第一个负数i，最后一个负数j; 
	4. 如果 i==j，那么分成2块，取大的那一块。
	5. 否则，取[L,j-1]和[i+1,R]中大的一块。

[O(n)](./uva11059.cpp)

### UVA-10976 Fractions Again?! 

题意:

已知正整数$k$,求 $1/k = 1/x + 1/y$ 的正整数解。

思路：

显然， $x = k*y / (y-k)$ , 因为 $x \ge y$，所以枚举 $y$ 从 $k+1$ 到 $2k$，即可。

[code](./uva10976.cpp)

### UVA-524 Prime Ring Problem

题意：

1~n摆成一个环，相邻两个之和为素数。

思路：

典型的dfs题目，首先n为非1奇数时无解（因为非2素数都是奇数），放数的时候，因为需要奇偶交替，可以稍微剪枝一下。 [code](./uva524.cpp)

### UVA-129 Krypton Factor

题意：

一个字符串如果不存在".SS."型的子串，被称为hard串。问在使用给定字符集范围的情况下，按字典序排序的第n个hard串。

思路：

暴力枚举。
对于第k个字符，枚举字符集中的字符。
如果放ch字符的话，是否存在SS型子串，不存在就得到一个新的hard串，继续递归放k+1个字符，直到id等于n停止。

我觉得这个问题有个很有意思的相关问题，证明L>=3时，这样的hard串有无穷多个？

[code](./uva129.cpp)

### UVA-140 Bandwidth

题意：

一个连通图，节点排列，相连节点在排列中的位置差最大的称为这个排列的带宽。求使其带宽最小的排列。

思路：

典型的排列枚举题，直接next_permutation模拟即可。读入的时候用正则能省不少事情。 [code](./uva140.cpp)

### UVA-1354 Mobile Computing

题意：

有s个节点，设计一个二叉树，使得所有子树都平衡，并使得最后二叉树的宽度在不超过限制的情况下尽可能的大。

思路：

0. 对于任意状态x，记录其左右子树宽度的集合x.s;
1. 对于状态u，枚举其不相交子集i和j，且i|j = u。
2. 如果i和j的状态已经计算过，否则计算其状态
3. 枚举i和j的所有合法组合，并加入到u.s

* 枚举u子集的方法 <code> for(i=(u-1)&u; i; i=(i-1)&u) </code>
* 枚举合法组合时，要注意左子树的右子树可能比右子树的右子树更远，同理，左子树的左子树可能比右子树的左子树更近；
* 枚举合法组合时，不需要考虑4种配对情况，因为本身枚举子集时，就会产生相同的配对。

[code](./uva1354.cpp)


### UVA-10603 Fill

题意：

三个水杯，容量依次为a,b,c,一开始第三个有满杯水，通过相互倒（不能把水撒出去）取得不超过d容量最近容量的最小倒水的累计和。

思路：

很奇怪为什么这个地方有这个题，这是典型的有向图最短路的题。

1. 先建图，每个节点为(i,j,k), i+j+k = c, 所以状态其实就是(i,j)。重边取小权边。
2. dijkstra求（0,0）到其他所有节点的最短距离
3. 枚举所有有效节点的最短距离（就是距离不是无穷大的），找答案即可。

[code](./uva10603.cpp)

代码跑的有点慢（写的有点啰嗦了），看了别人0ms的代码，用的堆优化的BFS，没有建图，而是在扩展的过程中扩展节点。
这样做其实核心和最短路没什么区别，但是有很多代码在压堆的时候，就把扩展节点标记为已访问，这样会有问题
<code>
S_0 ==d_i==>S_i--w_i--->S_n
S_0 ==d_j==>S_j--w_j--->S_n
</code>

比如 d_i < d_j 且 d_i + w_i > d_j + w_j,
那么 S_i 会先于 S_j 弹堆，那么S_i 扩展到S_n时，会将S_n 标记为已访问。
当S_j进行扩展时，因为S_n 已经标记为已访问，将不被扩展，从而导致错误。 

### UVA-1601 The Morning after Halloween

题意：

一个矩阵，里面有最多三个鬼，分别用a~c表示，要移动到A~C的位置。每次移动，三个鬼都可以移动到相邻的格子或者保持不动，但鬼的位置不能重叠或者互换。
地图保证每个2*2的子矩阵里一定有1个墙，求最小步数。

思路：

直接搞的话，状态太多了，首先矩阵点最多有$256$个，三个鬼的转移状态是$5^3-1=124$种，直接爆掉。

由于地图给的那个子矩阵条件，必然没有多少可移动的点（如果最外圈都是墙的话， 最多14*14-5*5 = 171 个，实际上应该大部分都不是这种极限数据），所以把这些点先预处理出来一个图，这样来减少整个图的顶点数和边数。

剩下的就是比较恶心的BFS，单向和双向都可以过，双向会稍微快点。

[bfs](./uva1601.cpp) [dbfs](./uva1601_dbfs.cpp)

另外这个题用IDA*的话，H函数不好找，效果并不好。

### UVA-11212 Editing a Book

题意：

n个元素的排列，可以把任意长度的切片换到任意的位置，问最少多少步让排列有序。

思路：

一开始想是不是DP，但一看n最大只有9，感觉就假了，后来发现这个题并没有最优子结构。既然是搜索章节，必然是搜索。

状态就是排列本身，剩下的主要是剪枝：

1. 我们很容易发现，最多只要搬运$\lceil\frac{n}{2}\rceil$长度的切片即可，而且只需要往后搬，不需要往前搬。
2. 另外，切片的位置如果把连续的切断了，肯定不会更好，这种情况就可以过滤掉，从而大大减少状态转移的数量。
3. h函数计算元素后继的不正确数量，如果状态转移产生的h更大，肯定不会是最优的。
4. 如果当前深度d,序列h值，最大深度maxd,满足$3d + h > 3maxd$的话，也不需要继续搜索了。因为一次切片操作最多减少h函数的值为3，即减少切片前一个元素，插入位置元素和切片尾部元素的h值。

[code](./uva11212.cpp)

### UVA-12325 Zombie's Treasure Chest 

题意：

容量为N的背包，两种物品，体积和价值分别为s1,v1,s2,v2。所有数据都是int32, 求最大价值和。

思路：

因为所有数据最大都有int32，背包DP的内存不够；2进制优化物品以后的子集枚举或者搜索会TLE。

首先，$peroid = lcm(s1,s2)$。在一个周期内，很容易判断出用哪种更好。这样对于容量N来说，最多包含n个周期。
如果 n > 1时， 必然 n-1个周期就很容易可得。我们只需要看1个周期和零头的里面，哪种组合最好就可以了。
所以用体积较大的物体，枚举即可。 时间复杂度为$O(\sqrt(N))$。 [code](./uva12325.cpp)

### UVA-1343 The Rotation Game 

题意：

一个井字型的拼图，两行两列可以循环移动，格子里有数字1~3，问最少多少步，可以让中间的8个格子数字相同，输出移动方法和最后中间格子的数字。

坑点： 不需要移动的时候也需要输出中间格子的数字！

思路：

典型搜索题，IDA*， H函数定义成中间8个格子中相同数字的个数。<code>d+8-h > maxd</code> 时剪枝。
枚举移动方向，当一个方向发生递归完成以后需要回溯，使得拼图复原。

[code](./uva1343.cpp)

### UVA-1374 Power Calculus

题意:

算n次幂，可以存下之前计算的结果，可以使用乘和除两种操作，问最少需要多少次运算？

坑： 没仔细看题目，以为就是可以用除法的快速幂，结果死活样例出不来。

思路：

对于已有的计算结果 $a_0,a_1,\ldots,a_d$，则$a_{d+1}$必然是$a_d$与$a_i, i<d$的组合。因为不含$a_d$的组合必然在之前的枚举中出现了。

### UVA-1602 Lattice Animals

题意：n个方块组成的图形，方块至少和另外一个方块有共边，图形如果经过旋转，翻转以后是一样的，被认为是同一种。问在给定的n个方块，宽为w，高为h的图形有多少种？

思路：

乍一看以为要上bunside引理求置换群的不动点，但是光生成对应的图形就不是件容易的事情。

生成图形

考虑加一个块到原来的图形上，看是否是新的图形。首先1块只有1种，然后递推产生$2,3,\ldots,10$块的图形。

sz块图形的产生过程如下：

```	
枚举所有sz-1块的图形
	枚举这个图形所有的方块
		枚举相邻的方块，如果是新的方块，那么产生一个sz块的图形t
			枚举已有的sz块图形，如果t是新的图形，那么加入sz块的图形集中。
```

注意的是，判断是否是新的时候，图形可以翻转以后再旋转，所以像俄罗斯方块那样的$4$块图形是5种，而不是7种。

产生过程中发现很慢，所以就打表了。

然后枚举所有的图形，依次填到a[n][w][h]数组中，最后打这个数组的表,即可。

[generator code](./uva1602_gen.cpp) 

[AC code](./uva1602.cpp)


### UVA-1603 Square Destroyer

题意:

一个$n \times n$的火柴棍组成的矩阵，已经去掉了一些火柴棍，问最少再去掉几根火柴棍能不存在正方形。

思路：

IDA*搜索，h函数为正方形的数量，用一个mask来记录边的状况。枚举边，如果存在的话且使得h减少的话，就递归。
还用了一个不太严谨的剪枝 <code> h > sz*(maxd-d) </code>, 大部分边删掉不会去掉超过sz的正方形数量。

跑得很慢，1190ms, 但是UVA上好像没有n=5的数据,过了。[ac_slow](.\uva1603.cpp)

上面跑得慢是因为枚举边的时候，边太多了。如果每次都能找个存在的正方形，效率应该会有提高。

1. 预处理，所有正方形和边的关系，建立正方形和边的两个索引表。
2. 每次找一个存在的正方形，枚举它的边，尝试删除，然后递归。

跑n=5的样例依然慢，但是比之前的快多了，0ms通过UVA的数据。[ac_fast](.\uva1603_fast.cpp)

lrj书上说得用dance link，不想写，留坑待填。 


### UVA-208 Firetruck

题意:

消防队在1号点，无向图，问到给定节点有几条路，要求打印路径和路径数。

思路：

坑题！！！

	1. 图居然可以不连通
	2. 没说必须按字典序输出路径
	3. 输出格式要求路径节点之间是一个空格，行首也没有空格。题目中没说，给的样例格式也不对！

先dfs求是否连通到终点。连通的情况下，再回溯（节点访问完清访问状态）寻找路径，记录路径到list，当访问终点时，输出路径，并路径数加一。


### UVA-225 Golygons 

题意:

有$n$步，走的距离依次$1~n$，每走一步必须左转或者右转，途中有一些点不能经过，问回到原点的路径和路径数。

坑：
1. 路径输出要字典序
2. 点不能重复到达

思路：

除去坑以外，题目还是有点意思，直接回溯就是了，可以加个剪枝，当剩下的数按奇偶分成两部分之和比对应坐标的绝对值还小时就可以不继续递归了。
可以发现只有$n=7,8,15,16$时有解，加个特判，这样可以跑到[120ms](./uva225.cpp)。

同时也可以发现，无禁止点的时候，路径其实也是非常少的，所以可以先打表，把无禁止点的合法路径都存下来，然后枚举即可，这样是[0ms](./uva225_fast.cpp)。 

### UVA-211 The Domino Effect

题意:

28张不同的骨牌，每张牌上有两个点数，$i,j, 0 \le i \le j \le 6$，骨牌可以横铺或者竖铺。
将所有骨牌铺到给定每格点数的$7 \times 8$格子中，问具体的铺法和方案数。

坑：

	1. 输出的格式说的数据之间有3个空行，格式错误会报WA
	2. 其他的照着样例输出写基本上没问题了。

思路

回溯即可，注意以下几点：
	
	1. 判断是否可铺的时候，需要判断两个点，不是一个点
	2. 边界处理分横竖处理。

感觉数据比较水，没有任何剪枝，20ms跑完了。 [code](./uva211.cpp)

### UVA-818 Cutting Chains

题意:

有n个环，有些环是扣在一起的。可以打开其中任意的环，再扣上。问最少打开几个环，使得所有的环都连接成一条锁链。

思路：

子集枚举打开的环，设打开k个环。
在某种打开环的子集下，dfs找单链的数量c，如果存在环或者不是单链，则失败；否则如果 c - 1 > k ,那么只需要打开c-1个环即可；否则打开k个环。

dfs找无向图的环和有向图找环类似，加入父节点，剔除掉父节点即可；单链的判断条件为，如果是根节点，那么孩子不超过2；否则不超过1；

据说有重边，用邻接矩阵作比较合适。因为n很小，我直接用位图来存邻接矩阵，枚举子集也可以使用位运算来完成。 [code](./uva818.cpp)

### UVA-690 Pipeline Scheduling

题意：

CPU有流水线有5个单元，10个完全相同的任务，任务需要$n$个时刻，每个时刻，任务会占用某些单元，安排流水线，使得10个任务单元占用不冲突，求最少使用的时刻数。

思路：

爆搜，直接用位运算来判断冲突，我手写个位图，但是效率并不高（应该是有大量的内存拷贝操作导致的）。 

朴素爆搜会超时，注意剪枝。

预处理合法的偏移值，如果<code>当前长度+最小合法偏移值*未安排任务数 >= 已知最优</code>，就剪枝。 [code](./uva690.cpp)
