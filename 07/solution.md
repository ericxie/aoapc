## 07 暴力求解


推荐：

* UVA-725	这个更像是个STL的题
* UVA-11059	这个想O(n)的算法，还是挺好的题。
* UVA-129	很常见的暴力枚举+递归的题
* UVA-140	枚举排列
* UVA-1354	枚举二叉树（必做）
* UVA-1601  构图优化BFS，双向BFS
* UVA-11212 IDA*
* UVA-1343  IDA*
* UVA-1374  IDA*
* UVA-1602  打表，生成程序有点意思。


不推荐：


-----

### UVA-725 Division

题意：

给一个N，找一个数码$0 \sim 9$的排列，使得 
$$
\frac{\;\overline{abcde}\;}{\;\overline{fghij}\;} = N
$$ 

思路：

$10! = 3628800$，直接枚举所有排列，计算N，对于查询，直接输出。 [code](./uva725.cpp)

### UVA-11059 Maximum Product

题意：

一个整数序列里，找出最大乘积的子段。

思路：

序列最大才18，所以可以用纯暴力$O(n^3)$ 或者 稍微优化一点的暴力 O(n^2)，都挺好写的。

其实这题可以用$O(n)$的算法解决。注意都是整数，所以如果都是非0的，乘积的绝对值是不会变小的。

	1. 如果存在某个元素是0，那么只需要计算之前和之后的，取大的即可。
	2. 对于一个不含0的序列区间[L,R]，如果负数的个数是偶数，那么结果是全部乘起来。
	3. 否则，找数列里第一个负数i，最后一个负数j; 
	4. 如果 i==j，那么分成2块，取大的那一块。
	5. 否则，取[L,j-1]和[i+1,R]中大的一块。

[O(n)](./uva11059.cpp)

### UVA-10976 Fractions Again?! 

题意:

已知正整数$k$,求 $1/k = 1/x + 1/y$ 的正整数解。

思路：

显然， $x = k*y / (y-k)$ , 因为 $x \ge y$，所以枚举 $y$ 从 $k+1$ 到 $2k$，即可。

[code](./uva10976.cpp)

### UVA-524 Prime Ring Problem

题意：

1~n摆成一个环，相邻两个之和为素数。

思路：

典型的dfs题目，首先n为非1奇数时无解（因为非2素数都是奇数），放数的时候，因为需要奇偶交替，可以稍微剪枝一下。 [code](./uva524.cpp)

### UVA-129 Krypton Factor

题意：

一个字符串如果不存在".SS."型的子串，被称为hard串。问在使用给定字符集范围的情况下，按字典序排序的第n个hard串。

思路：

暴力枚举。
对于第k个字符，枚举字符集中的字符。
如果放ch字符的话，是否存在SS型子串，不存在就得到一个新的hard串，继续递归放k+1个字符，直到id等于n停止。

我觉得这个问题有个很有意思的相关问题，证明L>=3时，这样的hard串有无穷多个？

[code](./uva129.cpp)

### UVA-140 Bandwidth

题意：

一个连通图，节点排列，相连节点在排列中的位置差最大的称为这个排列的带宽。求使其带宽最小的排列。

思路：

典型的排列枚举题，直接next_permutation模拟即可。读入的时候用正则能省不少事情。 [code](./uva140.cpp)

### UVA-1354 Mobile Computing

题意：

有s个节点，设计一个二叉树，使得所有子树都平衡，并使得最后二叉树的宽度在不超过限制的情况下尽可能的大。

思路：

0. 对于任意状态x，记录其左右子树宽度的集合x.s;
1. 对于状态u，枚举其不相交子集i和j，且i|j = u。
2. 如果i和j的状态已经计算过，否则计算其状态
3. 枚举i和j的所有合法组合，并加入到u.s

* 枚举u子集的方法 <code> for(i=(u-1)&u; i; i=(i-1)&u) </code>
* 枚举合法组合时，要注意左子树的右子树可能比右子树的右子树更远，同理，左子树的左子树可能比右子树的左子树更近；
* 枚举合法组合时，不需要考虑4种配对情况，因为本身枚举子集时，就会产生相同的配对。

[code](./uva1354.cpp)


### UVA-10603 Fill

题意：

三个水杯，容量依次为a,b,c,一开始第三个有满杯水，通过相互倒（不能把水撒出去）取得不超过d容量最近容量的最小倒水的累计和。

思路：

很奇怪为什么这个地方有这个题，这是典型的有向图最短路的题。

1. 先建图，每个节点为(i,j,k), i+j+k = c, 所以状态其实就是(i,j)。重边取小权边。
2. dijkstra求（0,0）到其他所有节点的最短距离
3. 枚举所有有效节点的最短距离（就是距离不是无穷大的），找答案即可。

[code](./uva10603.cpp)

代码跑的有点慢（写的有点啰嗦了），看了别人0ms的代码，用的堆优化的BFS，没有建图，而是在扩展的过程中扩展节点。
这样做其实核心和最短路没什么区别，但是有很多代码在压堆的时候，就把扩展节点标记为已访问，这样会有问题
<code>
S_0 ==d_i==>S_i--w_i--->S_n
S_0 ==d_j==>S_j--w_j--->S_n
</code>

比如 d_i < d_j 且 d_i + w_i > d_j + w_j,
那么 S_i 会先于 S_j 弹堆，那么S_i 扩展到S_n时，会将S_n 标记为已访问。
当S_j进行扩展时，因为S_n 已经标记为已访问，将不被扩展，从而导致错误。 

### UVA-1601 The Morning after Halloween

题意：

一个矩阵，里面有最多三个鬼，分别用a~c表示，要移动到A~C的位置。每次移动，三个鬼都可以移动到相邻的格子或者保持不动，但鬼的位置不能重叠或者互换。
地图保证每个2*2的子矩阵里一定有1个墙，求最小步数。

思路：

直接搞的话，状态太多了，首先矩阵点最多有$256$个，三个鬼的转移状态是$5^3-1=124$种，直接爆掉。

由于地图给的那个子矩阵条件，必然没有多少可移动的点（如果最外圈都是墙的话， 最多14*14-5*5 = 171 个，实际上应该大部分都不是这种极限数据），所以把这些点先预处理出来一个图，这样来减少整个图的顶点数和边数。

剩下的就是比较恶心的BFS，单向和双向都可以过，双向会稍微快点。

[bfs](./uva1601.cpp) [dbfs](./uva1601_dbfs.cpp)

另外这个题用IDA*的话，H函数不好找，效果并不好。

### UVA-11212 Editing a Book

题意：

n个元素的排列，可以把任意长度的切片换到任意的位置，问最少多少步让排列有序。

思路：

一开始想是不是DP，但一看n最大只有9，感觉就假了，后来发现这个题并没有最优子结构。既然是搜索章节，必然是搜索。

状态就是排列本身，剩下的主要是剪枝：

1. 我们很容易发现，最多只要搬运$\lceil\frac{n}{2}\rceil$长度的切片即可，而且只需要往后搬，不需要往前搬。
2. 另外，切片的位置如果把连续的切断了，肯定不会更好，这种情况就可以过滤掉，从而大大减少状态转移的数量。
3. h函数计算元素后继的不正确数量，如果状态转移产生的h更大，肯定不会是最优的。
4. 如果当前深度d,序列h值，最大深度maxd,满足$3d + h > 3maxd$的话，也不需要继续搜索了。因为一次切片操作最多减少h函数的值为3，即减少切片前一个元素，插入位置元素和切片尾部元素的h值。

[code](./uva11212.cpp)

### UVA-12325 Zombie's Treasure Chest 

题意：

容量为N的背包，两种物品，体积和价值分别为s1,v1,s2,v2。所有数据都是int32, 求最大价值和。

思路：

因为所有数据最大都有int32，背包DP的内存不够；2进制优化物品以后的子集枚举或者搜索会TLE。

首先，$peroid = lcm(s1,s2)$。在一个周期内，很容易判断出用哪种更好。这样对于容量N来说，最多包含n个周期。
如果 n > 1时， 必然 n-1个周期就很容易可得。我们只需要看1个周期和零头的里面，哪种组合最好就可以了。
所以用体积较大的物体，枚举即可。 时间复杂度为$O(\sqrt(N))$。 [code](./uva12325.cpp)

### UVA-1343 The Rotation Game 

题意：

一个井字型的拼图，两行两列可以循环移动，格子里有数字1~3，问最少多少步，可以让中间的8个格子数字相同，输出移动方法和最后中间格子的数字。

坑点： 不需要移动的时候也需要输出中间格子的数字！

思路：

典型搜索题，IDA*， H函数定义成中间8个格子中相同数字的个数。<code>d+8-h > maxd</code> 时剪枝。
枚举移动方向，当一个方向发生递归完成以后需要回溯，使得拼图复原。

[code](./uva1343.cpp)

### UVA-1374 Power Calculus

题意:

算n次幂，可以存下之前计算的结果，可以使用乘和除两种操作，问最少需要多少次运算？

坑： 没仔细看题目，以为就是可以用除法的快速幂，结果死活样例出不来。

思路：

对于已有的计算结果 $a_0,a_1,\ldots,a_d$，则$a_{d+1}$必然是$a_d$与$a_i, i<d$的组合。因为不含$a_d$的组合必然在之前的枚举中出现了。

### UVA-1602 Lattice Animals

题意：n个方块组成的图形，方块至少和另外一个方块有共边，图形如果经过旋转，翻转以后是一样的，被认为是同一种。问在给定的n个方块，宽为w，高为h的图形有多少种？

思路：

乍一看以为要上bunside引理求置换群的不动点，但是光生成对应的图形就不是件容易的事情。

生成图形

考虑加一个块到原来的图形上，看是否是新的图形。首先1块只有1种，然后递推产生$2,3,\ldots,10$块的图形。

sz块图形的产生过程如下：

```	
枚举所有sz-1块的图形
	枚举这个图形所有的方块
		枚举相邻的方块，如果是新的方块，那么产生一个sz块的图形t
			枚举已有的sz块图形，如果t是新的图形，那么加入sz块的图形集中。
```

注意的是，判断是否是新的时候，图形可以翻转以后再旋转，所以像俄罗斯方块那样的$4$块图形是5种，而不是7种。

产生过程中发现很慢，所以就打表了。

然后枚举所有的图形，依次填到a[n][w][h]数组中，最后打这个数组的表,即可。

[generator code](./uva1602_gen.cpp) 

[AC code](./uva1602.cpp)


### UVA-1603 Square Destroyer

题意:

一个$n \times n$的火柴棍组成的矩阵，已经去掉了一些火柴棍，问最少再去掉几根火柴棍能不存在正方形。

思路：

IDA*搜索，h函数为正方形的数量，用一个mask来记录边的状况。枚举边，如果存在的话且使得h减少的话，就递归。
还用了一个不太严谨的剪枝 <code> h > sz*(maxd-d) </code>, 大部分边删掉不会去掉超过sz的正方形数量。

跑得很慢，1190ms, 但是UVA上好像没有n=5的数据,过了。[ac_slow](.\uva1603.cpp)

上面跑得慢是因为枚举边的时候，边太多了。如果每次都能找个存在的正方形，效率应该会有提高。

1. 预处理，所有正方形和边的关系，建立正方形和边的两个索引表。
2. 每次找一个存在的正方形，枚举它的边，尝试删除，然后递归。

跑n=5的样例依然慢，但是比之前的快多了，0ms通过UVA的数据。[ac_fast](.\uva1603_fast.cpp)

lrj书上说得用dance link，不想写，留坑待填。 
