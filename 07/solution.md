## 07 暴力求解


推荐：

* UVA-11059	这个想$O(n)$的算法，还是挺好的题。
* UVA-129	很常见的暴力枚举+递归的题
* UVA-140	枚举排列
* UVA-1354	枚举二叉树（必做）
* UVA-1601  构图优化BFS，双向BFS
* UVA-11212 IDA*
* UVA-1343  IDA*
* UVA-1374  IDA*
* UVA-1602  打表，生成程序有点意思。
* UVA-818	题意有点费解，读懂题以后就是一个子集枚举+dfs的题。
* UVA-12113 枚举全排列的经典题
* UVA-12558 迭代加深搜索经典题
* UVA-12107 迭代加深+回溯
* UVA-307	经典的搜索剪枝题
* UVA-11846 回溯题，有点意思
* UVA-11694 回溯题，比较锻炼代码
* UVA-10384 BFS，状态压缩，路径打印

不推荐：

* UVA-208 坑，输出尤其坑

-----

### UVA-725 Division

题意：

给一个N，找一个数码$0 \sim 9$的排列，使得 
$$
\frac{\;\overline{abcde}\;}{\;\overline{fghij}\;} = N
$$ 

思路：

$10! = 3628800$，直接枚举所有排列，计算N，对于查询，直接输出。 [code](./uva725.cpp)

### UVA-11059 Maximum Product

题意：

一个整数序列里，找出最大乘积的子段。

思路：

序列最大才18，所以可以用纯暴力$O(n^3)$ 或者 稍微优化一点的暴力 O(n^2)，都挺好写的。

其实这题可以用$O(n)$的算法解决。注意都是整数，所以如果都是非0的，乘积的绝对值是不会变小的。

	1. 如果存在某个元素是0，那么只需要计算之前和之后的，取大的即可。
	2. 对于一个不含0的序列区间[L,R]，如果负数的个数是偶数，那么结果是全部乘起来。
	3. 否则，找数列里第一个负数i，最后一个负数j; 
	4. 如果 i==j，那么分成2块，取大的那一块。
	5. 否则，取[L,j-1]和[i+1,R]中大的一块。

[O(n)](./uva11059.cpp)

### UVA-10976 Fractions Again?! 

题意:

已知正整数$k$,求 $1/k = 1/x + 1/y$ 的正整数解。

思路：

显然， $x = k*y / (y-k)$ , 因为 $x \ge y$，所以枚举 $y$ 从 $k+1$ 到 $2k$，即可。

[code](./uva10976.cpp)

### UVA-524 Prime Ring Problem

题意：

1~n摆成一个环，相邻两个之和为素数。

思路：

典型的dfs题目，首先n为非1奇数时无解（因为非2素数都是奇数），放数的时候，因为需要奇偶交替，可以稍微剪枝一下。 [code](./uva524.cpp)

### UVA-129 Krypton Factor

题意：

一个字符串如果不存在".SS."型的子串，被称为hard串。问在使用给定字符集范围的情况下，按字典序排序的第n个hard串。

思路：

暴力枚举。
对于第k个字符，枚举字符集中的字符。
如果放ch字符的话，是否存在SS型子串，不存在就得到一个新的hard串，继续递归放k+1个字符，直到id等于n停止。

我觉得这个问题有个很有意思的相关问题，证明L>=3时，这样的hard串有无穷多个？

[code](./uva129.cpp)

### UVA-140 Bandwidth

题意：

一个连通图，节点排列，相连节点在排列中的位置差最大的称为这个排列的带宽。求使其带宽最小的排列。

思路：

典型的排列枚举题，直接next_permutation模拟即可。读入的时候用正则能省不少事情。 [code](./uva140.cpp)

### UVA-1354 Mobile Computing

题意：

有s个节点，设计一个二叉树，使得所有子树都平衡，并使得最后二叉树的宽度在不超过限制的情况下尽可能的大。

思路：

0. 对于任意状态x，记录其左右子树宽度的集合x.s;
1. 对于状态u，枚举其不相交子集i和j，且i|j = u。
2. 如果i和j的状态已经计算过，否则计算其状态
3. 枚举i和j的所有合法组合，并加入到u.s

* 枚举u子集的方法 <code> for(i=(u-1)&u; i; i=(i-1)&u) </code>
* 枚举合法组合时，要注意左子树的右子树可能比右子树的右子树更远，同理，左子树的左子树可能比右子树的左子树更近；
* 枚举合法组合时，不需要考虑4种配对情况，因为本身枚举子集时，就会产生相同的配对。

[code](./uva1354.cpp)


### UVA-10603 Fill

题意：

三个水杯，容量依次为a,b,c,一开始第三个有满杯水，通过相互倒（不能把水撒出去）取得不超过d容量最近容量的最小倒水的累计和。

思路：

很奇怪为什么这个地方有这个题，这是典型的有向图最短路的题。

1. 先建图，每个节点为(i,j,k), i+j+k = c, 所以状态其实就是(i,j)。重边取小权边。
2. dijkstra求（0,0）到其他所有节点的最短距离
3. 枚举所有有效节点的最短距离（就是距离不是无穷大的），找答案即可。

[code](./uva10603.cpp)

代码跑的有点慢（写的有点啰嗦了），看了别人0ms的代码，用的堆优化的BFS，没有建图，而是在扩展的过程中扩展节点。
这样做其实核心和最短路没什么区别，但是有很多代码在压堆的时候，就把扩展节点标记为已访问，这样会有问题
<code>
S_0 ==d_i==>S_i--w_i--->S_n
S_0 ==d_j==>S_j--w_j--->S_n
</code>

比如 d_i < d_j 且 d_i + w_i > d_j + w_j,
那么 S_i 会先于 S_j 弹堆，那么S_i 扩展到S_n时，会将S_n 标记为已访问。
当S_j进行扩展时，因为S_n 已经标记为已访问，将不被扩展，从而导致错误。 

### UVA-1601 The Morning after Halloween

题意：

一个矩阵，里面有最多三个鬼，分别用a ~ c表示，要移动到 A ~ C的位置。每次移动，三个鬼都可以移动到相邻的格子或者保持不动，但鬼的位置不能重叠或者互换。
地图保证每个2*2的子矩阵里一定有1个墙，求最小步数。

思路：

直接搞的话，状态太多了，首先矩阵点最多有$256$个，三个鬼的转移状态是$5^3-1=124$种，直接爆掉。

由于地图给的那个子矩阵条件，必然没有多少可移动的点（如果最外圈都是墙的话， 最多14*14-5*5 = 171 个，实际上应该大部分都不是这种极限数据），所以把这些点先预处理出来一个图，这样来减少整个图的顶点数和边数。

剩下的就是比较恶心的BFS，单向和双向都可以过，双向会稍微快点。

[bfs](./uva1601.cpp) [dbfs](./uva1601_dbfs.cpp)

另外这个题用IDA*的话，H函数不好找，效果并不好。

### UVA-11212 Editing a Book

题意：

n个元素的排列，可以把任意长度的切片换到任意的位置，问最少多少步让排列有序。

思路：

一开始想是不是DP，但一看n最大只有9，感觉就假了，后来发现这个题并没有最优子结构。既然是搜索章节，必然是搜索。

状态就是排列本身，剩下的主要是剪枝：

1. 我们很容易发现，最多只要搬运$\lceil\frac{n}{2}\rceil$长度的切片即可，而且只需要往后搬，不需要往前搬。
2. 另外，切片的位置如果把连续的切断了，肯定不会更好，这种情况就可以过滤掉，从而大大减少状态转移的数量。
3. h函数计算元素后继的不正确数量，如果状态转移产生的h更大，肯定不会是最优的。
4. 如果当前深度d,序列h值，最大深度maxd,满足$3d + h > 3maxd$的话，也不需要继续搜索了。因为一次切片操作最多减少h函数的值为3，即减少切片前一个元素，插入位置元素和切片尾部元素的h值。

[code](./uva11212.cpp)

### UVA-12325 Zombie's Treasure Chest 

题意：

容量为N的背包，两种物品，体积和价值分别为s1,v1,s2,v2。所有数据都是int32, 求最大价值和。

思路：

因为所有数据最大都有int32，背包DP的内存不够；2进制优化物品以后的子集枚举或者搜索会TLE。

首先，$peroid = lcm(s1,s2)$。在一个周期内，很容易判断出用哪种更好。这样对于容量N来说，最多包含n个周期。
如果 n > 1时， 必然 n-1个周期就很容易可得。我们只需要看1个周期和零头的里面，哪种组合最好就可以了。
所以用体积较大的物体，枚举即可。 时间复杂度为$O(\sqrt(N))$。 [code](./uva12325.cpp)

### UVA-1343 The Rotation Game 

题意：

一个井字型的拼图，两行两列可以循环移动，格子里有数字1~3，问最少多少步，可以让中间的8个格子数字相同，输出移动方法和最后中间格子的数字。

坑点： 不需要移动的时候也需要输出中间格子的数字！

思路：

典型搜索题，IDA*， H函数定义成中间8个格子中相同数字的个数。<code>d+8-h > maxd</code> 时剪枝。
枚举移动方向，当一个方向发生递归完成以后需要回溯，使得拼图复原。

[code](./uva1343.cpp)

### UVA-1374 Power Calculus

题意:

算n次幂，可以存下之前计算的结果，可以使用乘和除两种操作，问最少需要多少次运算？

坑： 没仔细看题目，以为就是可以用除法的快速幂，结果死活样例出不来。

思路：

对于已有的计算结果 $a_0,a_1,\ldots,a_d$，则$a_{d+1}$必然是$a_d$与$a_i, i<d$的组合。因为不含$a_d$的组合必然在之前的枚举中出现了。

[code](./uva1374.cpp)


### UVA-1602 Lattice Animals

题意：n个方块组成的图形，方块至少和另外一个方块有共边，图形如果经过旋转，翻转以后是一样的，被认为是同一种。问在给定的n个方块，宽为w，高为h的图形有多少种？

思路：

乍一看以为要上bunside引理求置换群的不动点，但是光生成对应的图形就不是件容易的事情。

生成图形

考虑加一个块到原来的图形上，看是否是新的图形。首先1块只有1种，然后递推产生$2,3,\ldots,10$块的图形。

sz块图形的产生过程如下：

```	
枚举所有sz-1块的图形
	枚举这个图形所有的方块
		枚举相邻的方块，如果是新的方块，那么产生一个sz块的图形t
			枚举已有的sz块图形，如果t是新的图形，那么加入sz块的图形集中。
```

注意的是，判断是否是新的时候，图形可以翻转以后再旋转，所以像俄罗斯方块那样的$4$块图形是5种，而不是7种。

产生过程中发现很慢，所以就打表了。

然后枚举所有的图形，依次填到a[n][w][h]数组中，最后打这个数组的表,即可。

[generator code](./uva1602_gen.cpp) 

[AC code](./uva1602.cpp)


### UVA-1603 Square Destroyer

题意:

一个$n \times n$的火柴棍组成的矩阵，已经去掉了一些火柴棍，问最少再去掉几根火柴棍能不存在正方形。

思路：

IDA*搜索，h函数为正方形的数量，用一个mask来记录边的状况。枚举边，如果存在的话且使得h减少的话，就递归。
还用了一个不太严谨的剪枝 <code> h > sz*(maxd-d) </code>, 大部分边删掉不会去掉超过sz的正方形数量。

跑得很慢，1190ms, 但是UVA上好像没有n=5的数据,过了。[ac_slow](.\uva1603.cpp)

上面跑得慢是因为枚举边的时候，边太多了。如果每次都能找个存在的正方形，效率应该会有提高。

1. 预处理，所有正方形和边的关系，建立正方形和边的两个索引表。
2. 每次找一个存在的正方形，枚举它的边，尝试删除，然后递归。

跑n=5的样例依然慢，但是比之前的快多了，0ms通过UVA的数据。[ac_fast](.\uva1603_fast.cpp)

lrj书上说得用dance link，不想写，留坑待填。 


### UVA-208 Firetruck

题意:

消防队在1号点，无向图，问到给定节点有几条路，要求打印路径和路径数。

思路：

坑题！！！

	1. 图居然可以不连通
	2. 没说必须按字典序输出路径
	3. 输出格式要求路径节点之间是一个空格，行首也没有空格。题目中没说，给的样例格式也不对！

先dfs求是否连通到终点。连通的情况下，再回溯（节点访问完清访问状态）寻找路径，记录路径到list，当访问终点时，输出路径，并路径数加一。


### UVA-225 Golygons 

题意:

有$n$步，走的距离依次$1~n$，每走一步必须左转或者右转，途中有一些点不能经过，问回到原点的路径和路径数。

坑：
1. 路径输出要字典序
2. 点不能重复到达

思路：

除去坑以外，题目还是有点意思，直接回溯就是了，可以加个剪枝，当剩下的数按奇偶分成两部分之和比对应坐标的绝对值还小时就可以不继续递归了。
可以发现只有$n=7,8,15,16$时有解，加个特判，这样可以跑到[120ms](./uva225.cpp)。

同时也可以发现，无禁止点的时候，路径其实也是非常少的，所以可以先打表，把无禁止点的合法路径都存下来，然后枚举即可，这样是[0ms](./uva225_fast.cpp)。 

### UVA-211 The Domino Effect

题意:

28张不同的骨牌，每张牌上有两个点数，$i,j, 0 \le i \le j \le 6$，骨牌可以横铺或者竖铺。
将所有骨牌铺到给定每格点数的$7 \times 8$格子中，问具体的铺法和方案数。

坑：

	1. 输出的格式说的数据之间有3个空行，格式错误会报WA
	2. 其他的照着样例输出写基本上没问题了。

思路

回溯即可，注意以下几点：
	
	1. 判断是否可铺的时候，需要判断两个点，不是一个点
	2. 边界处理分横竖处理。

感觉数据比较水，没有任何剪枝，20ms跑完了。 [code](./uva211.cpp)

### UVA-818 Cutting Chains

题意:

有n个环，有些环是扣在一起的。可以打开其中任意的环，再扣上。问最少打开几个环，使得所有的环都连接成一条锁链。

思路：

子集枚举打开的环，设打开k个环。
在某种打开环的子集下，dfs找单链的数量c，如果存在环或者不是单链，则失败；否则如果 c - 1 > k ,那么只需要打开c-1个环即可；否则打开k个环。

dfs找无向图的环和有向图找环类似，加入父节点，剔除掉父节点即可；单链的判断条件为，如果是根节点，那么孩子不超过2；否则不超过1；

据说有重边，用邻接矩阵作比较合适。因为n很小，我直接用位图来存邻接矩阵，枚举子集也可以使用位运算来完成。 [code](./uva818.cpp)

### UVA-690 Pipeline Scheduling

题意：

CPU的流水线有5个单元，10个完全相同的任务，任务需要$n$个时刻，每个时刻，任务会占用某些单元，安排流水线，使得10个任务单元占用不冲突，求最少使用的时刻数。

思路：

爆搜，直接用位运算来判断冲突，我手写个位图，但是效率并不高（应该是有大量的内存拷贝操作导致的）。 

朴素爆搜会超时，注意剪枝。

预处理合法的偏移值，如果<code>当前长度+最小合法偏移值*未安排任务数 >= 已知最优</code>，就剪枝。 [code](./uva690.cpp)


### UVA-12113 Overlapping Squares 

题意:

用$1 \sim 6$个$2 \times 2$的方块去铺一个$4 \times 4$的格子，问给出的图形是否能铺出来。

思路:

枚举$1 \sim 6$个方块的位置的全排列，所有的方案数为 $\sum_{i=1}^{6}P_i^9$。

用二进制表示图形，将图形映射成一个40bit的整数，每画一个方块，将8个边框线的位置置成1，中间4个框线的位置置成0。
打个表，查询即可。 [code](./uva12113.cpp)

### UVA-12558 Egyptian Fractions (HARD version) 

题意：

埃及分数加了禁止某些数为分母。

思路：

迭代加深搜索经典题，相对于一般的埃及分数题，扩展的时候查一下禁止数就好了。注意会爆int。

跑的很慢，接近2秒多了，我看VJ上有个大神写了个160ms跑完的，不知道是咋写的（没公开）。 [code](./uva12558.cpp)

### UVA-12107 Digit Puzzle

题意:

给一个最多是两位数之内的乘法等式，若干个数码位置上是通配符‘*’，可以将任意数码改成通配符或者其他数码，也可以将通配符改成某个数码，求最少改几位，使得满足等式的组合恰有1种。

思路：

很容易想到迭代加深搜索，但是这个题比较麻烦一点是先迭代加深搜索改变的位置得到一个新的等式，然后再回溯搜索这个等式满足的组合数量。

1. 搜索满足的组合时，朴素剪枝，发现超过1种，不继续递归。
2. 搜索满足的组合时，不要枚举所有的位置，只要枚举前两个数，看其乘积是否和后面可能含通配符的第三个串匹配
3. sscanf和sprintf都挺耗时的，我开始用这两个函数来偷懒算是否匹配，跑了1740ms，发现有人只跑了110ms，点进去看了，思路是一样的。我把sscanf改了，跑了500ms，再把sprintf改了，跑了100ms。(⊙o⊙)

[code](./uva12107.cpp)

### UVA-1604 Cubic Eight-Puzzle

题意:

积木块版本的8数码问题。积木块顶正侧分别为白红蓝，对面亦然。初始状态时的空格位置不固定，积木块可以往空格进行翻滚。
求给定顶面的颜色，在不超过30步里最少步数使得顶面颜色一致。

思路:

开始写了一个IDA*，发现巨慢；又写来一个bfs来爆所有的状态打表，依然巨慢。

因为状态数为$9 \cdot 6^8$，直接bfs也很慢，写了双向bfs。

6进制位压缩积木块的状态，组合空格的坐标构成节点状态。

需要主要的一点就是 终止状态有 $2^8$个，所以双向广搜的时候，正向多搜几层，逆向少搜几层会更快点。

测了一下各搜15层，跑了1480ms，正21层逆9层，跑了400ms。

[code](./uva1604.cpp)

### UVA-11214 Guarding the Chessboard

题意:

类似N皇后问题，问最少放几个皇后，攻击范围能覆盖所有给定的点。

思路:

与N皇后问题类似，但是注意，同一行或同一列可能不止一个皇后！只能按一个一个位置进行回溯。
另外判断结局时，不能光判断标记位，比如$8\times 8$时，把第一行的前面5个都涂掉，会使得第6对角线行也被全部被涂掉。

[code](./uva11214.cpp)

另外，VJ上有个70msAC的代码是错的，那份代码假定皇后不同列，下面的数据能Cha掉。

```
8 8
X.X.....
XXXXXXXX
X.X.....
....X...
...X....
X.......
XXXXXXXX
X.X.....
0
```

另外，我还写了一个[位运算的版本](./uva11214_bit.cpp)，但是时间差不多。

### UVA-12569 Planning mobile robot on Tree (EASY Version)

题意:

华容道问题，一棵树，机器人从s到t，中间有m个障碍，问最少步数和移动方案。

思路:

直接BFS。双广的话，终态可能有上千个，觉得反而搜了很多无效的状态。

用A*的话，可能会快一点，但是H函数很不好弄。
可以考虑先预处理树上任意两点的距离，然后看起点到终点的路径上是否有障碍物，有的话， 计算这些障碍物到不在起点到终点路径上的空白点的距离。这个写起来会很烦。

利用19位对状态进行编码，前15位表示节点占用情况，后4位表示机器人所在位置。
由于需要记录移动方案，需要额外记录某状态的前继状态和移动。 [code](./uva12569.cpp)

VJ上有个0ms的提交，看了代码觉得很不科学，还用了无用的优先队列，代码写的也挺丑的。


### UVA-1533 Moving Pegs

题意:

跳棋，一个三角形的棋盘，一开始有一个空格，一个棋子可以沿着直线跨越1或更多的连续的棋子跳到空格里，跨越的棋子被消掉。
问最后棋盘上只剩一个棋子，且正好在初始棋盘空格处的最少移动步数和方案。

坑：
题目没说移动方案需要最小字典序！

思路:

利用位压缩存储棋盘状态，优先队列BFS打个表。 [打表代码](./uva1533.cpp) [AC代码](./uva1533_1.cpp)

### UVA-817 According to Bartjens

题意:

一个只含数码和结尾为等号的字符串，可以随意添加“+-*”三种二元运算，保证没有前导0的数字，问至少添加一个运算的情况下，有几个合法的表达式结果等于2000。

思路:

算符文法+递归枚举。枚举所有位置不加入运算符和加入运算符，得到一个表达式，再计算这个表达式，是否等于2000.

枚举的时候，要看token的首字符是否为0。

[code](./uva817.cpp)


### UVA-307 Sticks

题意：

$n$个木棍，正好拼成若干个等长的棍子，问最小的长度是多少？

思路:

经典的搜索剪枝题

首先，基础的搜索框架是 

1. 对木棍进行降序排列，统计棍子总长，最长棍子长度
2. 枚举等长棍子的长度 len ，它至少是最长棍子的长度，且是总长的因子。再结合总长，计算出等长棍子的数量 sz。
3. 对于等长的长度和数量，回溯进行搜索，基础状态为(curr,num,k)，表示已拼长度，已拼好棍子数量，待处理的棍子序号。

然后是剪枝

1. 找到第一个可用的k，（k木棍未使用，且curr + item[k] <= len，最长的木棍）  
2. 找到最后一个可用的最短的木棍 last
3. 计算k与last之间所有可用木棍的总长total,如果curr + total < len，那么搜索失败。
4. 枚举i木棍，从k到last

	a. 如果 curr + item[i] == len, 那么必然是用i木棍，如果失败，没必要尝试其他的。
	b. 如果 i != last 且 curr + item[i] + item[last] > len, 那么i不可用，尝试下一个。
	c. 如果i木棍搜索失败，且 curr为0，那么就搜索失败，没必要尝试其他的；
	d. 如果i木棍搜索失败，与i木棍相同长度的也会失败，找到下一个不同长度的木棍。

有一些构造的数据，搜索会很慢，不过搜索剪枝题就是这样子，有些玄学。

[code](./uva307.cpp)

### UVA-11882 Biggest Number

题意：

一个$R \times C$的方格，里面有些格子里有$1 \sim 9$的的数码，格子只能经过一次，问按顺序经过格子，可以组成的最大数。

思路：

枚举每个数码格，回溯查最大的数。没剪枝的时候会TLE，简单的剪枝就是，对于到达某一格，查询剩下最多能再找到多少个格子，
如果不够现在已知最大的长度长或者长度相等，但是字典序不会更好就剪枝。[code](./uva11882.cpp)


### UVA-11846 Finding Seats Again

题意:

有点像扫雷，一个$n \times n$的方阵，有$K$个团体，方阵中的数码表示是某个团体的leader，数值是这个团体的人数，团体是按矩形占位的。
请输出每个团体的占位情况。

思路:

一开始直接按leader，纯暴力去回溯TLE了。
换一个思路，先枚举所有的leader，预处理出所有位置能被哪些leader，什么样的矩形覆盖。
然后，再按位置去回溯即可，注意回溯时仍然要判断是否合法。但因为预处理了，每个点被覆盖的方案是很有限的，所有回溯时的量相对之前少了非常多。

[code](./uva11846.cpp)


### UVA-11694 Gokigen Naname

题意:

在一个矩阵每个格子上填上对角线(有且仅有一个),使得所有对角线不形成回路和保证某些交点上的连接对角线的数量是给定的量。

思路：

明显回溯的题，代码比较难写。

1. 按格子里面的对角线进行回溯
2. 对于回路的判断，利用并查集，由于要回溯，所以并查集不能用路径压缩。回溯的时候，需要把并查集恢复到合并前的状态。
3. 对于每个交点，计算交点的度要求deg，维护现在已有的度curr，还没有枚举的格子数upp，保证对于每个格子，如果四个交点的度如果有要求的话，必须满足curr <= deg <= curr + upp

我写了一个巨长的条件判断的预处理，把一开始就能确定的对角线先填上了，其实不写也是可以的。或者用dfs的方式来做预处理，应该写的会简单一些，而且能先填上更多的确定的对角线。

[code](./uva11694.cpp)

回路判断，维护图，直接搜应该也不会超时，毕竟数据量很小。

坑: 1. 样例数据是错的，没有样例数

### UVA-10384 The Wall Pushers 

题意:

一个$4 \times 6$的格子迷宫，如果没有墙，可以移动到相邻格，或者有墙，但是目的格同方向无墙，那么可以推动墙，并移动。
不允许移动边界的墙，问最少步数走出迷宫的路径。

思路：

典型的BFS题，用位压缩存储迷宫的墙（一共58位），加上坐标x和y作为判重状态，使用hash判重。 [code](./uva10384.cpp)