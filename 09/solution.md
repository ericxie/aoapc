## 09 动态规划初步


推荐：

* UVA-437 	DAG上的DP例题
* UVA-1347  思维上有些锻炼
* UVA-116	数塔基础题
* UVA-12563 完全背包

不推荐：


---

### UVA-1025 A Spy in the Metro

题意：

N个站线性排列，间谍初始在1号站，他需要在T时刻在N号站，有若干趟车按一定时刻从1或者N站开出，每站之间的运行时间是固定的。
间谍可以瞬间在车站切换列车（如果车辆正好到站），求其在站台的最少等待时间。

思路：

既然是DP章节，自然是DP题，不过这个题和最短路差不多，BFS+优先队列更容易理解些，虽然本质上是一样的。
节点状态为(v,t,p)，表示t时刻在p站最少等待时间是v。对于任何一个节点，最多只有三种状态可扩展
	
	1. 等一分钟
	2. 搭往右走的车，如果第t时刻在p站有往右的车
	3. 塔往左走的车，如果第t时刻在p站有往左的车

初始节点为(0,0,1),终止节点为(ans,T,N)。

[code](./uva1025.cpp)

### UVA-437 The Tower of Babylon

题意：

n种积木块，每种都无限多个，积木块可以翻转，要求底部矩形严格单调，请问最多能堆多高。


思路：

本质上就是DAG上的DP，和1025其实是一个套路。
状态为dp[i][j] 表示最高层为第i类积木的最高高度，j=0,1,2分别表示以三个不同边作为高。

dp[i][j] = max{dp[k][t] + block[i][j]} , if block[i][j] 与 block[k][t] 的 底部严格单调减小。   

还是按BFS+优先队列写的，不过刘汝佳书上的写法（相当于先建图，然后跑一次dfs求最长路）也挺巧妙的，可以学习一下。

[code](./uva437.cpp)

### UVA-1347 Tour

题意：

在平面上，所有点的x坐标唯一，从最左边的点出发，达到最右边的点，然后返回最左点，所有点都经过也只经过一次，问最短距离。

思路：

1. 相当于从最左的点走两条路A和B，最后汇合到最右边的点。对于路途上的点，要么在路A上，要么在路B上。
2. 反过来想，dp(i,j)表示A路到i点，B路到j点时，离汇合到最右边点的最短距离。不妨设i>j，因为dp(i,j) = dp(j,i)。 dist(i,j)为i和j的欧氏距离。
3. 如果此时，已经到达(n-1,j) 那么 dp(n-1,j) = dist(n,n-1) + dist(n,j) | 1 <= j <= n-2; 边界条件
4. dp(i,j) = min{ dp(i+1,j) + dist(i+1,i) , dp(i+1,i) + dist(i+1,j) }

题目没告诉你点的数量，不过因为是$n^2$的算法，所以猜1000。

[code](./uva1347.cpp)

### UVA-116 Unidirectional TSP

题意：

一个n*m的矩阵，从最左边到最右边，走过的最短距离。 矩阵上下是连通的，每次可以往右边走相邻的三个点。

思路：

其实就是个数塔，倒着推。打印路径的时候，先确定第一列，然后每次枚举右边相邻的三个点，找距离最小且行数最小的。

读错题(没仔细读，以为是从最左上到最右下)，WA+1;
路径打印想错了，以为是每列最小的那个，WA+1；
没看n和m最大有100，WA+1。

[code](./uva116.cpp)

### UVA-12563 Jin Ge Jin Qu hao

题意：

n+1首歌曲，时长限制下(最后一首歌不会被切)最多能唱多少首，时长最长的歌。
有一首劲歌金曲，长达678秒，其他歌曲不会超过180秒。

思路：

典型的01背包问题，我一开始以为是求最长，直接写了一个01背包，然后WA了。
发现是求最多歌，第二优先级是最长，改成完全背包即可（改边界条件即可。）

1. 因为JGJQ是最长，所以一定会唱这首，直接计算时限-1的容量下最多唱多少首能恰好用完容量。
2. 最后求最多首歌的最大容量，加上JGJQ即可。

[code](./uva12563.cpp)

### UVA-11400 Lighting System Design

题意：

n种灯泡，每种灯泡有电压，电源费用，单价，所需个数。
如果电压相同，可以共用一个电源。
可以用高电压的灯泡代替低或平电压的灯泡，
请问最少花费。

思路：

1. 一种灯泡要么全部被替换，要么不被替换。（否则多出的电源费用肯定更亏）
2. 灯泡按电压排序，计算前缀个数和$cnt_i$
3. $dp_i$ 表示前i种灯泡的最少花费
4. $dp_i = \min \{ dp_j + (cnt_i - cnt_j) \cdot lamp_i.c + lamp_i.k \mid 0 \le j \lt i \}$

[code](./uva11400.cpp)