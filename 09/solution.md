## 09 动态规划初步


推荐：

* UVA-1025  DAG上的DP例题
* UVA-437 	DAG上的DP例题
* UVA-1347  思维上有些锻炼
* UVA-116	数塔基础题
* UVA-12563 完全背包
* UVA-11400 LIS
* UVA-11584 预处理，LIS
* UVA-1625	LCS变形+计数
* UVA-10003 区间DP，顺便学一下四边形不等式优化
* UVA-1220  经典树形DP
* UVA-1218	经典树形DP，状态设计难一些
* UVA-10817 三进制状压DP

不推荐：

* UVA-1620 输入太坑爹了，直接影响做题心情。

---

### UVA-1025 A Spy in the Metro

题意：

N个站线性排列，间谍初始在1号站，他需要在T时刻在N号站，有若干趟车按一定时刻从1或者N站开出，每站之间的运行时间是固定的。
间谍可以瞬间在车站切换列车（如果车辆正好到站），求其在站台的最少等待时间。

思路：

既然是DP章节，自然是DP题，不过这个题和最短路差不多，BFS+优先队列更容易理解些，虽然本质上是一样的。
节点状态为(v,t,p)，表示t时刻在p站最少等待时间是v。对于任何一个节点，最多只有三种状态可扩展
	
	1. 等一分钟
	2. 搭往右走的车，如果第t时刻在p站有往右的车
	3. 塔往左走的车，如果第t时刻在p站有往左的车

初始节点为(0,0,1),终止节点为(ans,T,N)。

[code](./uva1025.cpp)

### UVA-437 The Tower of Babylon

题意：

n种积木块，每种都无限多个，积木块可以翻转，要求底部矩形严格单调，请问最多能堆多高。


思路：

本质上就是DAG上的DP，和1025其实是一个套路。
状态为dp[i][j] 表示最高层为第i类积木的最高高度，j=0,1,2分别表示以三个不同边作为高。

dp[i][j] = max{dp[k][t] + block[i][j]} , if block[i][j] 与 block[k][t] 的 底部严格单调减小。   

还是按BFS+优先队列写的，不过刘汝佳书上的写法（相当于先建图，然后跑一次dfs求最长路）也挺巧妙的，可以学习一下。

[code](./uva437.cpp)

### UVA-1347 Tour

题意：

在平面上，所有点的x坐标唯一，从最左边的点出发，达到最右边的点，然后返回最左点，所有点都经过也只经过一次，问最短距离。

思路：

1. 相当于从最左的点走两条路A和B，最后汇合到最右边的点。对于路途上的点，要么在路A上，要么在路B上。
2. 反过来想，dp(i,j)表示A路到i点，B路到j点时，离汇合到最右边点的最短距离。不妨设i>j，因为dp(i,j) = dp(j,i)。 dist(i,j)为i和j的欧氏距离。
3. 如果此时，已经到达(n-1,j) 那么 dp(n-1,j) = dist(n,n-1) + dist(n,j) | 1 <= j <= n-2; 边界条件
4. dp(i,j) = min{ dp(i+1,j) + dist(i+1,i) , dp(i+1,i) + dist(i+1,j) }

题目没告诉你点的数量，不过因为是$n^2$的算法，所以猜1000。

[code](./uva1347.cpp)

### UVA-116 Unidirectional TSP

题意：

一个n*m的矩阵，从最左边到最右边，走过的最短距离。 矩阵上下是连通的，每次可以往右边走相邻的三个点。

思路：

其实就是个数塔，倒着推。打印路径的时候，先确定第一列，然后每次枚举右边相邻的三个点，找距离最小且行数最小的。

读错题(没仔细读，以为是从最左上到最右下)，WA+1;
路径打印想错了，以为是每列最小的那个，WA+1；
没看n和m最大有100，WA+1。

[code](./uva116.cpp)

### UVA-12563 Jin Ge Jin Qu hao

题意：

n+1首歌曲，时长限制下(最后一首歌不会被切)最多能唱多少首，时长最长的歌。
有一首劲歌金曲，长达678秒，其他歌曲不会超过180秒。

思路：

典型的01背包问题，我一开始以为是求最长，直接写了一个01背包，然后WA了。
发现是求最多歌，第二优先级是最长，改成完全背包即可（改边界条件即可。）

1. 因为JGJQ是最长，所以一定会唱这首，直接计算时限-1的容量下最多唱多少首能恰好用完容量。
2. 最后求最多首歌的最大容量，加上JGJQ即可。

[code](./uva12563.cpp)

### UVA-11400 Lighting System Design

题意：

n种灯泡，每种灯泡有电压，电源费用，单价，所需个数。
如果电压相同，可以共用一个电源。
可以用高电压的灯泡代替低或平电压的灯泡，
请问最少花费。

思路：

1. 一种灯泡要么全部被替换，要么不被替换。（否则多出的电源费用肯定更亏）
2. 灯泡按电压排序，计算前缀个数和$cnt_i$
3. $dp_i$ 表示前i种灯泡的最少花费
4. $dp_i = \min \{ dp_j + (cnt_i - cnt_j) \cdot lamp_i.c + lamp_i.k \mid 0 \le j \lt i \}$

[code](./uva11400.cpp)

### UVA-11584 Partitioning by Palindromes

题意：

求一个字符串最少切成多少个子串，使得所有子串都是回文串。

思路：

显然，dp[L][R] 表示区间[L,R]之间最少分的回文子串数。

dp[L][R] = min { R-L+1, dp[L][i-1] + dp[i][R] | if s[i] == s[R]}。

但是这样会有N*N个状态，和每个状态，N次的状态转移，时间复杂度达到$O(N^3)$。

其实，可以发现只有存在回文串时才会产生新的有效状态，所以可以预处理pal[i][j],表示i到j之间是否是回文串。
枚举字符串的所有字符作为回文串的中点（奇数长度）或左中点（偶数长度），两点拓展即可。

然后， dp[i] 表示前i个字符的最少分的回文子串数。

dp[i] = min{i, dp[j-1] + 1 | s[j~i]组成回文串}。

这样预处理是$O(n^2)$的，dp是$O(n^2)$，整个算法时间复杂度降为$O(n^2)$

[code](./uva11584.cpp)


### UVA-1625 Color Length 

题意：

两个颜色（大写字母表示）序列合并成一个序列，每种颜色c的代价是 c出现最晚的位置 - c出现最早的位置，
求合并后序列，所有颜色代价最小是多少。

思路：

如果设计状态为 dp[i][j] 表示a序列前i个，b序列前j个的最小代价，那么

dp[i][j] = min{dp[i][j-1] + dist(i,j-1,b[j]) , dp[i-1][j] + dist(i-1,j,a[i])}

但是，这个状态不是无后效性的，计算dist会和之前的序列有关系。

重新设计状态，dp[i][j] 表示a序列前i个，b序列前j个的合并序列对最终结果的贡献值。

dp[i][j] = min{dp[i][j-1] , dp[i-1][j] } + delta(i,j)

其中，delta(i,j)，表示已经归并了a串前i和b前j-1个字符的情况下，归并b[j]对于结果的贡献；
也表示为已经归并了a串前i-1和b前j个字符的情况下，归并a[i]对于结果的贡献； 这个两个其实是一样的。

问题就在于怎么计算这个delta。

某种字符处于已经开始被归并，还没有完全被归并完时，这时如果归并一个字符，必然对这种字符的代价产生+1的影响。

所以统计每种字符在a和b串中的最小和最大位置，分别为al,ar,bl,br; 此时(i,j)如果处于
(al <= i || bl <= j) && (i < ar || j < br) 时， 则必然对这种字符的代价+1。

最后发现dp只和两个点相关，空间为n*m的，而delta也是n*m的，所以可以复用空间，直接用dp即可。

时间复杂度为 O(k*n*m) , k为字符集大小

[code](./uva1625.cpp)

### UVA-10003 Cutting Sticks

题意：

一个长度为L的木棍，要在n个地方切开，每次切开的代价为切开前木棍的长度，问最小代价是多少？

思路：

n很小，最大才50。

所以直接$O(n^3)$的区间DP即可。

dp[i][j] 表示从刻度i到刻度j区间的最小代价

dp[i][j] = min{dp[i][k] + dp[k][j]} + a[j] - a[i] ， i < k < j

a[i]表示第i个刻度的值。 

[n^3](./uva10003.cpp)

这个题也可以进一步使用四边形不等式优化到O(n^2)。[n^2](./uva10003_fast.cpp)

不过数据比较水，没优化才跑了60ms，优化以后也跑20ms，并不是太明显。

具体四边形不等式的证明等可以查看 
[罗勇军老师写的四边形不等式的Blog](https://blog.csdn.net/weixin_43914593/article/details/105150937),不过里面的证明符号容易把人搞晕。
或者看李煜东《算法竞赛进阶指南》的相关章节。

### UVA-1620 Brackets sequence

题意：

找一个小中括号的正确匹配最短字符串。

思路：

典型的区间DP，

dp[i][j] = min{dp[i][k]+dp[k+1][j] , dp[i][k-1] + dp[k+1][j] | when s[k] 与 s[j] 匹配}。

题目要求打印匹配后的字符串，利用递归即可。

1. 区间为1时，直接打印匹配的一对
2. 如果区间首尾匹配， 且 dp[i][j] = dp[i+1][j-1] , 输出s[i],递归(i+1,j-1),输出s[j]
3. 否则，枚举k，如果dp[i][j] = dp[i][k] + dp[k+1][j] , 递归(i,k),递归(k+1,j),break;

<em>输入极其坑爹，有空串样例，只能用gets。题目也没说是SPJ的，实际就是SPJ的</em>

[code](./uva1626.cpp)

### UVA-12186 Another Crisis 

题意：

一个公司，人事系统是一棵树，叶子称为工人，中间节点称为老板。
需要提一份申请书，不能越级。只有直系下属超过T%，这个人才会往上提交。
问提交到根节点，最少需要多少个工人提交申请书？

思路：

这题不像是DP（没有决策），就是一个树上的统计问题。

1. 记录节点的父亲、儿子集合
2. dfs根。如果节点是叶子（无儿子节点），那么其代价为1；否则，dfs其n个儿子节点，取儿子节点中前m位(m = ceil(n*T/100))的代价和作为这个节点的代价。
3. 根的代价即为求解。

[code](./uva12186.cpp)


### UVA-1220 Party at Hali-Bula

题意：

一棵树，只能同时取父节点和子节点的情况下， 最多取多少个节点，且这些节点组成是否是唯一的。

思路：

这题有两问，先考虑最大节点数。

对于点u, u.s0表示不取u时的最大节点数，u.s1表示取u时的最大节点数。
显然，如果u是叶子，那么u.s0 = 0,u.s1=1.
否则， 假设v是u 的孩子， u.s1 = sum (v.s0) , u.s0 = sum (max (v.s0,v.s1))

再考虑唯一性问题。

对于点u，u.t0表示不取u时的唯一性，u.t1表示取u时的唯一性。 唯一为false，否则为true。
显然，如果u是叶子，那么u.t0 = false,u.t1 = false.
否则，对于u.t1，必须 sum(v.t0) = 0 时为 false。
对于u.t0, 当选择某个子节点的s0 = s1时，则必为true。另外，当选择了某个子节点子节点数多的方案时，如果这个方案的t为true，则也为true。

想清楚了，下面就是很简单dfs就可以搞定了。

注意的是，题目给出的数据不是按树的层次给的，所以在查找名字的时候，两个都要查。

[code](./uva1220.cpp)


### UVA-1218 Perfect Service

题意：

一棵树，求最少染多少个点，使得所有点都被染色或者其相邻点被染色。

思路：

考虑一下在符合题目要求下，某点u的情况。假设u的父节点为p，u的子节点为v_i；染色为1，未染色为0。

0. p=0，u=0。这时最少染色点，必然是v_i 中有一个v_k = 1 ， 其他v_i = 0。
1. u=1。这时v_i 可以=1，也可以=0，取小值即可。
2. p=1，u=0。这时最少染色点，必然是所有v_i = 0。

所以，我们用u的s0,s1,s2 分别表示以上的三个状态。

下面我们来考虑v_i到u的状态转移。

1. u.s1 = sum { min{v_i.s1, v_i.s2} }
2. u.s2 = sum { v_i.s0 }
3. u.s0 = sum {v_i.s0} + min{ v_i.s1 - v_i.s0}  = u.s2 +  min{ v_i.s1 - v_i.s0 }

边界条件: leaf.s1 = 1, leaf.s2 = 0, leaf.s0 = inf;

注意计算时，u.s2 和 u.s1 要注意防止溢出。

答案是 根节点的min{s0,s1} (因为根节点没有父节点，所以s2是无效的。)。

[code](./uva1218.cpp)

### UVA-10817  Headmaster's Headache 

题意：

学校有s门课，老师有薪水和能上的科目。已经有m个老师，现在有n份求职，问最少多少薪水能使得每门课至少有2个老师能上。

思路:

s <= 8 ， 明显的状压dp

因为一门课的状态为0,1,2，所以需要用三进制，考虑到方便处理，用4进制来存储状态。注意某一科的状态如果为3，那么需要改回为2。

dp[i][j] 表示前i份求职状态为j时的最小代价。

已有的m个老师，计算其工资总和sum，状态总和flag。

dp[0][j] = inf, dp[0][flag] = sum;

对于 dp[i-1][t1] , 其影响两个点，一个是 dp[i][t1], 表示不聘用第i份求职的状态；
另一个是dp[i][t2], 其中t2是t1在聘用第i份求职以后变成的状态。

	dp[i][t1] = dp[i-1][t1];
	dp[i][t2] = min(dp[i-1][t2],dp[i-1][t1] + post[i].salary)

[code](./uva10817.cpp)

