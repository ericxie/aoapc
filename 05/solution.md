## 05 C++ 与 STL

* UVA-101 不用STL容器的话，是个挺不错的基础数据结构练习题。
* UVA-12096 多种STL容器的综合使用，超级暴力
推荐： UVA-101，UVA-12096

---

### UVA-10474 Where is the Marble?

题意： N个数，排序以后，查询x。

排序，二分即可。

[code](./uva10474.cpp)

### UVA-101 The Block Problem

题意：n个块，初始是n行，四种指令移动块，求最后块排放情况（如果同一个块在同一行为无效指令）

没仔细看题，以为没有无效指令，结果直接TLE了。

既然在STL章节，这个当然可以用STL来模拟搞。可以用stack，list等。
注意到块移动目标是块，而且第i块如果不在第i行，第i行必然为空。
所以用prev[i]和next[i]第i块的前驱和后继即可，有点像写个双向链表的操作。

[code](./uva101.cpp)


### UVA-10815 Andy's First Dictionary

题意： 给一个不超过5000行的文字，提取单词（无视大小写），把所有单词按字典序输出。

直接用set存string其实就行了，不过我还是写了字典树。

坑点： 可能有" -- ","good-bye"

知识漏洞： fread 读入字符数不够给定最大值时，要手动设置字符串结束，否则后面会被重复填充一堆。

[code](./uva10815.cpp)


### UVA-156 Ananagrams

题意: 一些单词，如果这些单词在无视大小写的情况下可以通过调整顺序得到彼此，认为是重复。按字典序输出不重复的单词。

方法很多，可以生成单词全小写后排序的字符串作为key，用map来计数，然后把不重复的排序（书上的做法）。

我的做法是，先得到字符串的key，然后把字符串按key排序，然后用两点将重复的标出来，然后再按重复标识和字符串排个序，输出。


### UVA-12096 The SetStack Computer 

题意：一个栈，元素为集合，有五种操作，push,dup,union,intersect,add，涉及到集合的操作，问每次指令后栈顶元素的大小。

不错的题目，考察多种STL容器的使用。我开始一直想怎么弄个编码和译码能快速查询集合与编号的对应关系，实在是找不到特别高效的方法，
看了书发现，这tm也太暴力了，居然用 <code>map<set<int>,int></code> 这样的东西，这不会慢成狗吗？不过题目的指令最多才2000条，
这么暴力倒也不会超时。

书上的代码对于U和I操作的时间复杂度是 $O(nlogn)$的，A操作的时间复杂度是$O(n)$。我嫌弃set操作太慢，改成用list，三个操作的时间复杂度都为$O(n)$。

思路就是把集合编码，一开始编号池和集合池为空。
如果产生的新集合不在编号池内，就产生一个新的编号，并将集合加入集合池，集合和编号对加入编号池。
否则那就取对应的编号。
U和I操作利用STL的集合合并和相交操作即可。
A操作，获得栈顶元素x1和次栈顶元素x2，获得x1的编码，插入x2的顺序表中，再将更新（不一定会变化）后的x2的编号压栈。