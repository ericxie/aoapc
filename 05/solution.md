## 05 C++ 与 STL

推荐：

* UVA-101 不用STL容器的话，是个挺不错的基础数据结构练习题。
* UVA-12096 多种STL容器的综合使用，超级暴力
* UVA-1592 经典的字符串hash题
* UVA-221 离散化启蒙题

不推荐：

* UVA-207 题目细节很多的，但是描述得不清，坑点很多。
题目也没有可用的样例来验证，自己构造数据也很麻烦（我是写了一个程序来构造数据的，手工构造不现实）。

---

### UVA-10474 Where is the Marble?

题意： N个数，排序以后，查询x。

排序，二分即可。

[code](./uva10474.cpp)

### UVA-101 The Block Problem

题意：n个块，初始是n行，四种指令移动块，求最后块摆放情况（如果同一个块在同一行为无效指令）

没仔细看题，以为没有无效指令，结果直接TLE了。

既然在STL章节，这个当然可以用STL来模拟搞。可以用stack，list等。
注意到块移动目标是块，而且第i块如果不在第i行，第i行必然为空。
所以用prev[i]和next[i]第i块的前驱和后继即可，有点像写个双向链表的操作。

[code](./uva101.cpp)


### UVA-10815 Andy's First Dictionary

题意： 给一个不超过5000行的文字，提取单词（无视大小写），把所有单词按字典序输出。

直接用set存string其实就行了，不过我还是写了字典树。

坑点： 可能有" -- ","good-bye"

知识漏洞： fread 读入字符数不够给定最大值时，要手动设置字符串结束，否则后面会被重复填充一堆。

[code](./uva10815.cpp)


### UVA-156 Ananagrams

题意: 一些单词，如果这些单词在无视大小写的情况下可以通过调整顺序得到彼此，认为是重复。按字典序输出不重复的单词。

方法很多，可以生成单词全小写后排序的字符串作为key，用map来计数，然后把不重复的排序（书上的做法）。

我的做法是，先得到字符串的key，然后把字符串按key排序，然后用两点将重复的标出来，然后再按重复标识和字符串排个序，输出。

[code](./uva156.cpp)


### UVA-12096 The SetStack Computer 

题意：一个栈，元素为集合，有五种操作，push,dup,union,intersect,add，涉及到集合的操作，问每次指令后栈顶元素的大小。

不错的题目，考察多种STL容器的使用。我开始一直想怎么弄个编码和译码能快速查询集合与编号的对应关系，实在是找不到特别高效的方法，
看了书发现，这tm也太暴力了，居然用 <code>map< set< int >, int></code> 这样的东西，这不会慢成狗吗？不过题目的指令最多才2000条，
这么暴力倒也不会超时。

书上的代码对于U和I操作的时间复杂度是 $O(nlogn)$的，A操作的时间复杂度是$O(n)$。我嫌弃set操作太慢，改成用list，三个操作的时间复杂度都为$O(n)$。

思路就是把集合编码，一开始编号池和集合池为空。
如果产生的新集合不在编号池内，就产生一个新的编号，并将集合加入集合池，集合和编号对加入编号池。
否则那就取对应的编号。
U和I操作利用STL的集合合并和相交操作即可。
A操作，获得栈顶元素x1和次栈顶元素x2，获得x1的编码，插入x2的顺序表中，再将更新（不一定会变化）后的x2的编号压栈。


[code](./uva12096.cpp)


### UVA-540 Team Queue

题意： n个团队的人排队，如果前面有自己团队的人，那么插到自己团队最后一个的后面；否则排到队伍最后。问出队的编号。

一个队列排团队号，t个队列分别排每个团队的号，模拟就可以了。

数据有问题，在团队编号和指令之间不止一个回车，回车之前有不定量的空白符！！！！

[code](./uva540.cpp)

### UVA-136 Ugly Numbers

题意：只含质因子2,3,5的称为丑数，求第1500个丑数。

POJ 丑数的简化版，一个队列，3个队头，一个队尾。

[code](./uva136.cpp)

### UVA-400 Unix ls

题意：模拟ls命令的显示效果，一行最多60个字符，n个文件名按字典序，按列优先输出。每个文件名占宽是最长文件名的长度，靠左对齐，每两个占宽之间有2个空格。

统计最长文件名长度，计算出列数和行数，然后输出即可，注意行末边界的处理。

[code](./uva400.cpp)


### UVA-1592 Database

题意：一个表，找是否存在不同行的两个不同列相同？

注意到行数很大，列数很小，所以枚举两个列的组合，hash判断之前是否有相同的列值组合。

[code](./uva1592.cpp)


### UVA-207 PGA Tour Prize Money

题意： PGA巡回赛的排名计算，细节很多，题目没有具体的样例输入和输出，格式有些地方靠猜，有些线索不是很清楚，注意下坑点。

* T 必须是<b>参入奖金分配的才有</b>，我开始以为职业选手并列就行（好吧，没仔细读题）
* 第一轮是选前70名（含并列）选手，不区分业余和职业
* 所有输出行尾没有多余的空格！！！
	- "Money Won"后面没有；
	- 没有获得奖金的职业选手，输出总成绩后不用空格。

思路：大模拟嘛，也没啥好说的。我的做法中几个便于写的处理：

1. 用大数来代替没打的杆数，便于排序；
2. 第二轮计算两个排名，一个全部选手的排名，一个职业选手的排名；
3. 善用sscanf的返回值，比LRJ那个写法简便清晰很多

[code](./uva1592.cpp)

### UVA-814 The Letter Carrier's Rounds

题意： SMTP的模拟，注意以下坑点（题目中都有说）：

* 没有正确的接收人的话，不用发数据
* 重复的接收人，只要处理一次

[code](./uva814.cpp)

### UVA-221 Urban Elevations

题意： 给一些平行于坐标轴长方体，求正视图中，那些长方体能被看到。输出这些长方体的编号，按长方体左下角(x,y)坐标排序。

思路：本来想写个离散化线段树，后来发现需要写树套树，嫌太麻烦了，放弃掉了。

先离散化，保留下所有的端点x坐标，然后排序，去重之后，得到扫描线。
下面有两种思路：

* LRJ的做法是对于每个立方体，枚举所有扫描线，对于某一个扫描线，判断这个立方体是否可见，时间复杂度是$O(n^3)$。
  这种好写。[code](./uva221.cpp)

* 对于每条扫描线，枚举立方体，维护一个可见立方体列表，最后把这个列表合并到可见立方体集合中。
  枚举立方体过程中，可以删掉在扫描线左边的立方体，来减少一些时间消耗。
  最坏时间复杂度依然是$O(n^3)$，不过平均应该会好很多。[code](./uva221-1.cpp)

### UVA-1593 Aligment of Code

题意: 将每行单词按列最长单词的宽度对齐。

思路：分割出每行单词，维护每列的宽度，最后再输出这些单词。

写了两个版本，一个用[STL](./uva1593.cpp)，一个[NO STL](./uva1593-1.cpp)

### UVA-1594 Ducci Sequence

题意：一个数字序列，视为一个环，迭代计算，下一次的值为与顺时钟下一个元素差值的绝对值。问是变成全0还是有循环节？假定1000次内会有结果。

思路：模拟就可以，不知道为何放在这章。 [code](./uva1594.cpp)

