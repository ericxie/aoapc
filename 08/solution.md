## 08 高效算法设计


推荐：

* UVA-1152 	经典hash题
* UVA-11134	经典贪心，区间覆盖问题
* UVA-11054	经典两点
* UVA-1606	经典的极角排序，环上二分题，新人需要先了解一点计算几何的知识。、
* UVA-11572	经典两点法。
* UVA-1471	和LIS有点像，虽然需要用到二分，但是主要还是个DP，利用单调队列来优化。
* UVA-1451	
* UVA-714 	经典最大值最小化问题
* UVA-12627 找规律，递归。
* UVA-1608	两点，递归
* UVA-1442	扫描，贪心


不推荐：



-----

### UVA-120 Stacks of Flapjacks

题意：

有一堆饼子，直径为1到100之间，不超过30个。你可以把一个区间的饼子翻转顺序，问将饼子按直径从小到大排序的操作序列。

题看着有点烦，看了半天，连例子都没看明白。。。原来它是按从下到上算位置的。

思路：

和选择排序差不多，每次找当前最大的，放到最后面去。
当前最大的饼的位置分三种情况： 

1. 在最上面，直接翻转当前数量的区间；
2. 在当前最下面，不用翻转；
3. 其他情况，把最大的翻转到最上面，再翻转到最下面。

没仔细看题，以为是饼子半径是从1到n的。。。WA了一发。

[code](./uva120.cpp)

### UVA-1605 Building for UN 

题意：

n个国家，建一栋楼，办公室房间组成的区域是矩形的，所有国家都有办公室是相邻的，构造一种划分方案。

题意有点费解，我开始以为一个国家只能占一块地方，n多了必然无解。结果是，可以占多个地方，这就很假了。
建两层即可，第一层行排列，第二层列排列。

[code](./uva1605.cpp)

### UVA-1152 4 Values whose Sum is 0 

题意：

4个集合ABCD，任取每个集合里的一个元素，其和值为0，求有多少组？

思路:

典型的Hash题，先枚举AB组合得到值，存入hash表，统计次数；再枚举CD组合的值的负值，查表，累加次数。

[STL](./uva1152.cpp) 跑了4s多， 手工[hash](./uva1152_m.cpp)版本跑了不到1s。

注意，随机情况下，hash表可能有将近16M个节点，一定要开够，要不会RE。

### UVA-11134 Fabled Rooks 

题意:

$n \times n$的国际象棋棋盘，上面放$n$个车，车放的区域必须在给定的矩形范围内，保证相互不能攻击到。
问放置方案。

思路：

先简化一下，考虑一维的情况，问题等价于$n$个区间，是否能覆盖$[1,n]$?
我们将所有区间按右端点，左端点排序，枚举i=1到n，在已经排好序的区间中，按顺序选一个未使用能覆盖i的区间。

二维的情况，只要分别处理x和y就可以了。

[code](./uva11134.cpp)


### UVA-11054 Wine trading in Gergovia

题意：

一个数列，把正数移动到负数的位置，使得所有数为0，每次移动的代价为移动值 $\times$ 距离。求最小代价。

思路：

典型的两点法。 一个点指向最左的正数，一个点指向最左的负数，计算移动代价，再维护这两个点。

[O(n)](./uva11054)

### UVA-1606 Amphiphilic Carbon Molecules 

题意:

$n$个点，颜色为黑色和白色，用一条直线将其划分成两部分，使得一边白点+另一边黑点的数量最多。求这个最值。

思路：

枚举，计算几何-极角排序，倍增，二分。

枚举一个点为原点，将其他点平移（黑点再相对原点对称）,再转换成极坐标（求极角），并排序。

问题转换成前n-1个极角开始的，长度为PI的区间内最多有多少个点的问题。

倍增极角数组，将小于0的极角+2PI 放到数组里，然后枚举前n-1个极角arc[i]，二分查找 arc[i] + PI的上限，计算区间的点数，并维护最大值。

[code](./uva1606.cpp)

### UVA-11572 Unique Snowflakes

题意：

一个数列，找一个不含重复元素的连续子列的最长长度。

思路：

典型的两点法。维护每个数的左端点和目前不重复元素子列的左端点left，移动右端点，看新的数。

新的数有三种情况

1. 没出现过的，直接记录这个数的位置
2. 出现过，但是之前的位置在left之前，更新这个数的位置
3. 否则，当前位置 - left 为这个不重复元素子列的长度，更新left和答案即可。

注意，最后循环结束，还要算一次最后的那个子列。

[code](./uva11572.cpp)

### UVA-1471 Defense Lines 

题意：

求一个数字序列，在可以去掉一段连续的子段以后，最长的严格单调递增子段的长度。

思路：

一开始没仔细读题，以为是LIS，结果WA了。

1. 先预处理每个数结尾的最长长度left和开头的最长长度right.（两点法，分别从头到尾和从尾到头分别求得left和right）
2. f[i] 表示 以a[i]为结尾，之前最多去掉一个连续子段的最长单调上升子列长度。
   f[i] = max {f[j]} + 1, j < i and a[j] < a[i]; 显然，答案 = max{f[i] + right[i]}。
   朴素的做法显然是$O(n)$的。
3. dp[i]表示长度为i+1的所有单调子列的最后一个数字的最小值,显然dp是单调的。
   所以，我们可以对于a[i]，在dp中二分找出之前最长的单调子列的长度，使得状态转移从$O(n)$转换成$O(logn)$。
   从而使得总体的时间复杂度将为$O(nlogn)$。
4. 假设当前dp的大小为sz，对于dp的维护规则为：
	a. 如果 left[i] > dp[sz - 1] , 那么 dp[sz++] = a[i];
	b. 否则, 如果 a[i] < dp[left[i]], 那么就更新dp[left[i]];

[code](./uva1471.cpp)

### UVA-1451 Average 

挖坑待填

### UVA-714 Copying Books

题意:

将$n$个数字按原顺序分成$k$段，使得每个段的累加和最大值最小，给出划分方案，存在多个方案时，尽量使得前面的段的累加和最小。

思路：

典型的最大值最小化问题，二分+贪心验证求出段的最小值，然后从数列尾部开始划分，保证每段不会超过容量，并前面剩余元素数不低于剩余段数。

注意：累加和可能爆int。划分的时候不能光看容量，还要保证剩余元素不低于剩余段数。

[code](./uva714.cpp)

### UVA-10954 Add All

题意：

n个数，每次两个相加得到一个新的数，代价是和值，一直迭代，直到只有1个数为止。问最小代价。

思路：

哈夫曼编码，堆模拟即可。

[code](./uva10954.cpp)

### UVA-12627 Erratic Expansion 

题意：

一个分型格子图，格子的边长为$2^k$，$k=1$时，为红格。 当$k=n+1$时，分成$4$个边长为$2^{k-1}$的图形，右下角为全蓝色格，其他为$k=n$时的图形。
对于每个查询$K,A,B$，求$[A,B]$行之间有多少个红色格子。

思路:

观察可知，边长$k$的图形，一共有$3^k$红格。对于$1\sim r$行的图形

$$
g(r,k)=
\left\{
\begin{array}
\,0 & r = 0   \\
3^k & r = 2^k \\
2\cdot g(r,k-1) & r \le 2^{k-1} \\
2\cdot 3^{k-1} + g(r-2^{k-1},k-1) & else  
\end{array}
\right.
$$

[code](./uva12627.cpp)

### UVA-11093 Just Finish it up

题意：

顺时钟环形竞速赛，给出去下一站需要的汽油数和本站能得到的汽油数，一开始车是没油的，问从最小编号的站点出发能完成比赛。

思路：

相当于给n个数组成环，求是否存在一个n长的序列，其前缀和一直是非负的。

直接计算$c_i = a_i - b_i$，倍增$c$，两点法求最长非负子段和。

[code](./uva11093.cpp)

### UVA-1608 Non-boring sequences

题意:

判断字符串是否满足任何子串都含唯一元素。

思路:

对于`a[i]`计算其最近的左右同值元素的位置`left[i]`和`right[i]`，如果不存在`left[i]=-1`，`right[i] = n`;

对于区间$[L,R]$，如果存在某个唯一元素`a[i]`,其 `left[i] < L && right[i] > R`, 那么只要判断$[L,i-1]$和$[i+1,R]$是否满足即可。

注意，查找唯一元素时，要双向查找，否则会TLE。

[code](./uva1608.cpp)


### UVA-1442 Cav

题意:

一个洞，二维平面上，每个列上有下限和上限，表示地板和天花板。往里面灌燃料，燃料不能到天花板，问最大能存多少单位？

思路:

给的样例是图里的左半部分（15列）。

相当于找每列最高的液面高度。

先从左到右扫描，液面高度为从这个列开始，往右的最高液面高度。

根据左边液面高度`f[i-1]`与当前的地板`p[i]`和天花板高度`s[i]`之间关系，维护当前液面高度。分成三种情况：

1. `f[i-1] < p[i]` 			: `f[i] = p[i]`
2. `p[i] <= f[i-1] <= s[i]` : `f[i] = f[i-1]`
3. `f[i-1] > s[i]` 			: `f[i] = s[i]`

再从右到左扫描，更新液面高度为最高的存储液面高度。

根据右边液面高度`f[i+1]`与当前液面高度`f[i]`、当前的地板`p[i]`之间关系，维护当前液面高度。存在两种情况：

1. `f[i+1] < f[i]`			: `f[i] = f[i+1]`     右边的比当前低，那么只能使用低的
2. `f[i] < p[i]` 			: `f[i] = p[i]`		  当前液面比地板低，那么就用地板的

[code](./uva1442.cpp)


